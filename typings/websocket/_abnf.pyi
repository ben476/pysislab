"""
This type stub file was generated by pyright.
"""

from typing import Callable, Union
from ._exceptions import *

__all__ = ['ABNF', 'continuous_frame', 'frame_buffer', 'STATUS_NORMAL', 'STATUS_GOING_AWAY', 'STATUS_PROTOCOL_ERROR', 'STATUS_UNSUPPORTED_DATA_TYPE', 'STATUS_STATUS_NOT_AVAILABLE', 'STATUS_ABNORMAL_CLOSED', 'STATUS_INVALID_PAYLOAD', 'STATUS_POLICY_VIOLATION', 'STATUS_MESSAGE_TOO_BIG', 'STATUS_INVALID_EXTENSION', 'STATUS_UNEXPECTED_CONDITION', 'STATUS_BAD_GATEWAY', 'STATUS_TLS_HANDSHAKE_ERROR']
STATUS_NORMAL = ...
STATUS_GOING_AWAY = ...
STATUS_PROTOCOL_ERROR = ...
STATUS_UNSUPPORTED_DATA_TYPE = ...
STATUS_STATUS_NOT_AVAILABLE = ...
STATUS_ABNORMAL_CLOSED = ...
STATUS_INVALID_PAYLOAD = ...
STATUS_POLICY_VIOLATION = ...
STATUS_MESSAGE_TOO_BIG = ...
STATUS_INVALID_EXTENSION = ...
STATUS_UNEXPECTED_CONDITION = ...
STATUS_SERVICE_RESTART = ...
STATUS_TRY_AGAIN_LATER = ...
STATUS_BAD_GATEWAY = ...
STATUS_TLS_HANDSHAKE_ERROR = ...
VALID_CLOSE_STATUS = ...
class ABNF:
    """
    ABNF frame class.
    See http://tools.ietf.org/html/rfc5234
    and http://tools.ietf.org/html/rfc6455#section-5.2
    """
    OPCODE_CONT = ...
    OPCODE_TEXT = ...
    OPCODE_BINARY = ...
    OPCODE_CLOSE = ...
    OPCODE_PING = ...
    OPCODE_PONG = ...
    OPCODES = ...
    OPCODE_MAP = ...
    LENGTH_7 = ...
    LENGTH_16 = ...
    LENGTH_63 = ...
    def __init__(self, fin: int = ..., rsv1: int = ..., rsv2: int = ..., rsv3: int = ..., opcode: int = ..., mask: int = ..., data: Union[str, bytes] = ...) -> None:
        """
        Constructor for ABNF. Please check RFC for arguments.
        """
        ...
    
    def validate(self, skip_utf8_validation: bool = ...) -> None:
        """
        Validate the ABNF frame.

        Parameters
        ----------
        skip_utf8_validation: skip utf8 validation.
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    @staticmethod
    def create_frame(data: Union[bytes, str], opcode: int, fin: int = ...) -> ABNF:
        """
        Create frame to send text, binary and other data.

        Parameters
        ----------
        data: str
            data to send. This is string value(byte array).
            If opcode is OPCODE_TEXT and this value is unicode,
            data value is converted into unicode string, automatically.
        opcode: int
            operation code. please see OPCODE_MAP.
        fin: int
            fin flag. if set to 0, create continue fragmentation.
        """
        ...
    
    def format(self) -> bytes:
        """
        Format this object to string(byte array) to send data to server.
        """
        ...
    
    @staticmethod
    def mask(mask_key: Union[str, bytes], data: Union[str, bytes]) -> bytes:
        """
        Mask or unmask data. Just do xor for each byte

        Parameters
        ----------
        mask_key: bytes or str
            4 byte mask.
        data: bytes or str
            data to mask/unmask.
        """
        ...
    


class frame_buffer:
    _HEADER_MASK_INDEX = ...
    _HEADER_LENGTH_INDEX = ...
    def __init__(self, recv_fn: Callable[[int], int], skip_utf8_validation: bool) -> None:
        ...
    
    def clear(self) -> None:
        ...
    
    def has_received_header(self) -> bool:
        ...
    
    def recv_header(self) -> None:
        ...
    
    def has_mask(self) -> Union[bool, int]:
        ...
    
    def has_received_length(self) -> bool:
        ...
    
    def recv_length(self) -> None:
        ...
    
    def has_received_mask(self) -> bool:
        ...
    
    def recv_mask(self) -> None:
        ...
    
    def recv_frame(self) -> ABNF:
        ...
    
    def recv_strict(self, bufsize: int) -> bytes:
        ...
    


class continuous_frame:
    def __init__(self, fire_cont_frame: bool, skip_utf8_validation: bool) -> None:
        ...
    
    def validate(self, frame: ABNF) -> None:
        ...
    
    def add(self, frame: ABNF) -> None:
        ...
    
    def is_fire(self, frame: ABNF) -> Union[bool, int]:
        ...
    
    def extract(self, frame: ABNF) -> list:
        ...
    


